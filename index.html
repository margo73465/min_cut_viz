<!DOCTYPE html>
<meta charset="utf-8">
<style>

rect {
  fill: none;
  pointer-events: all;
}

.node {
  fill: #000;
}

.cursor {
  fill: none;
  stroke: brown;
  pointer-events: none;
}

.link {
  stroke: #999;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/min_cut_funcs.js"></script>
<script>

var width = 960,
  	height = 720;

var fill = d3.scale.category10();
var PI = 3.14159265359

var nodes = [];
var edges = [];
var mLinkNum = {};

var force = d3.layout.force()
    .size([width, height])
    .nodes(nodes)
    .links(edges)
    .linkDistance(150)
    .charge(-300)
    .friction(0.1)
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

var node = svg.selectAll(".node");
    link = svg.selectAll(".link");

// var arc = d3.svg.arc()
//     .innerRadius(10)
//     .outerRadius(10)
//     .startAngle(PI/10)
//     .endAngle(PI/10);

// var link = svg.selectAll("path")
//       .data(force.links()).enter()
//         .append("svg:path")
//         .attr("class", "link");

function start() {
  //link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
  link = link.data(edges);
  link.enter()
    //.insert("svg:path", ".node")
    .insert("line", ".node")
    .attr("class", "link");
  link.exit()
    .remove();

  node = node.data(force.nodes(), function(d) { return d.id; });
  node.enter()
    .append("circle")
    .attr("class", function(d) { return "node " + d.id; })
    .attr("r", 8)
    .call(force.drag);
  node.exit().remove();

  force.start();
}

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
  
  // link.attr("d", function(d) {
  //   var dx = d.target.x - d.source.x,
  //       dy = d.target.y - d.source.y,
  //       dr = Math.sqrt(dx * dx + dy * dy);
    
  //   // get the total link numbers between source and target node
  //   var lTotalLinkNum = mLinkNum[d.source.id + "," + d.target.id] || mLinkNum[d.target.id + "," + d.source.id];
  //   if(lTotalLinkNum > 1)
  //   {
  //     // if there are multiple links between these two nodes, we need generate different dr for each path
  //     dr = dr/(1 + (1/lTotalLinkNum) * (d.linkindex - 1));
  //   }     
    
  //   // generate svg path
  //   return "M" + d.source.x + "," + d.source.y + 
  //     "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + 
  //     "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y;  
  // })

  //link.attr("d", function(d) { return arc(d); })

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .style("fill", function(d) { return fill(d.weight); });
}


d3.json("/random_graph.json", function(error, data) {

	for (var a = 0; a < data.length; a++) {
		nodes.push( {id: data[a][0]} );
		for (var b = 1; b < data[a].length; b++) {
			if (+data[a][b] > +data[a][0]) { // Ensures that we only add each edge one time
				edges.push( { source: +data[a][0], target: +data[a][b] } );
			}
		}
	}

  // used to store the number of links between two nodes.   
  // mLinkNum[edges[i].source + "," + edges[i].target] = edges[i].linkindex;
  mLinkNum = {};
  
  // sort links first
  sort_links(edges);                
  
  // set up linkIndex and linkNumer, because it may possible multiple links share the same source and target node
  setLinkIndexAndNum();

  console.log(nodes);
  console.log(edges);
  //count_links(edges);

  // test = [{source: 0, target: 1}, {source: 0, target: 1}, {source:0, target:2}]
  // sort_links(test);

	start();	

	var interval = setInterval(function() { 

		// Randomly choose an edge
		var edge_index = Math.floor(Math.random() * edges.length);
		var edge = edges[edge_index];	

    //svg.append()

		// Mash nodes together, all edges connected to second node are now connected to first
		var node_index = edge.target.index;
		edges = find_and_replace(edges, edge.target, edge.source)
		edges = remove_self_loops(edges);
		nodes.splice(node_index, 1);
		
		console.log(nodes.slice(0));
		console.log(edges.slice(0));

		if (nodes.length <= 2) {
      start();
			clearInterval(interval);
      //svg.append.text("HELLO");
		} else {
			start();
		}

	}, 1300);

})

function sort_links(links)
{               
  links.sort(function(a,b) {
    if (a.source.id > b.source) 
    {
      return 1;
    }
    else if (a.source < b.source) 
    {
      return -1;
    }
    else 
    {
      if (a.target > b.target) 
      {
        return 1;
      }
      if (a.target < b.target) 
      {
        return -1;
      }
      else 
      {
        return 0;
      }
    }
  });
}

//any links with duplicate source and target get an incremented 'linknum'
function setLinkIndexAndNum()
{               
  for (var i = 0; i < edges.length; i++) 
  {
    if (i != 0 &&
      [i].source == edges[i-1].source &&
      edges[i].target == edges[i-1].target) 
    {
      edges[i].linkindex = edges[i-1].linkindex + 1;
    }
    else 
    {
      edges[i].linkindex = 1;
    }
    // save the total number of links between two nodes
    if(mLinkNum[edges[i].target + "," + edges[i].source] !== undefined)
    {
      mLinkNum[edges[i].target + "," + edges[i].source] = edges[i].linkindex;
    }
    else
    {
      mLinkNum[edges[i].source + "," + edges[i].target] = edges[i].linkindex;
    }
  }
} 

// function count_links(edges) {
//   var unique_edges = [];
//   for (var i = 0; i < edges.length; i++) {
//     if (unique_edges.indexOf(edges[i]) < 0) {
//       unique_edges.push(edges[i]);
//     }
//   }

//   console.log(unique_edges);

//   for (var i = 0; i < unique_edges.length; i++) {
//     //var edge_group = [];
//     edge_group = edges.filter( function (element) {
//       return element == unique_edges[i];
//     });
//     console.log(edge_group);
//   }
// }

</script>